//
// Created by IcePig on 2020-08-01.
//
// for easy each bucket = 1Bytes

#include <iostream>
#include <vector>
#include "filter_policy.h"
#include "util/hash.h"

static uint32_t BloomHash(const std::string &key) {
    // string.data() exclude '/0'
    // string.c_str() include '/0'
    return Hash(key.c_str(), key.size(), 0xbc9f1d34);
}

class CountBloomFilterPolicy : public FilterPolicy {
private:
    size_t buckets_per_key_; // m/n
    size_t k_;               // hash function nums
    size_t bytes_;           // total bytes
    std::string data_;       // bit data

public:
    //记录bits_per_key，计算最优的hash函数个数
    explicit CountBloomFilterPolicy(int buckets_per_key, int key_num)
            : buckets_per_key_(buckets_per_key), data_(std::string()) {
        // We intentionally round down to reduce probing cost a little bit
        // buckets_per_key = m / n  根据公式传入 buckets_per_key
        // 相当于传入了希望的错误率，会自动算出需要使用的哈希函数个数k
        // m = -[(n * lnp)/(ln2)^2]     p:p(error)
        // k_ = ln(2) * buckets_per_key
        k_ = static_cast<size_t>(buckets_per_key * 0.69);  // 0.69 =~ ln(2)
        // [1, 30]个hash函数
        if (k_ < 1) k_ = 1;
        if (k_ > 30) k_ = 30;
        std::cout<<"====================="<<std::endl;
        std::cout<<k_<<std::endl;
        // Compute bloom filter size (in both bits and bytes)
        // 计算需要的bit数
        // for easy each bucket = 1Bytes
        size_t bits = key_num * buckets_per_key * 8;
        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;

        bytes_ = (bits + 7) / 8;
        bits = bytes_ * 8;

        data_.resize(bytes_, 0);
        data_.push_back(static_cast<char>(k_));
    }

    virtual const char *Name() const {
        return "leveldb.BuiltinBloomFilter->CountBloomFilter";
    }

    virtual void AddKey(const std::string *keys, int n) const {
        char *array = (char *) (data_.c_str());//更新array <-> data_[0 :bytes]
        for (int i = 0; i < n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            // uint32_t 32bit
            // https://www.cnblogs.com/loujiayu/p/3821108.html
            //Gi(x)=H1(x)+iH2(x)
            //H2(x)=(H1(x)>>17) | (H1(x)<<15)
            uint32_t h = BloomHash(keys[i]);
            const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits 循环右移17位
            for (size_t j = 0; j < k_; j++) {
                //计算并更新对应的Bytes++
                const uint32_t bucket_pos = h % bytes_;
                // 对应bucket++
                // array[bucket_pos / 8] |= (1 << (bucket_pos % 8));
                if (0 <= array[bucket_pos] < 255) {
                    std::cout << "before ++" <<int(array[bucket_pos]) << std::endl;
                    array[bucket_pos]++;
                    std::cout << "after ++" << int(array[bucket_pos]) << std::endl;
                }
                h += delta;
            }
        }
    }

    virtual bool DeleteKey(const std::string &key) const {
        char *array = (char *) (data_.c_str());//更新array <-> data_[0 :bytes]
        // Use double-hashing to generate a sequence of hash values.
        // See analysis in [Kirsch,Mitzenmacher 2006].
        // uint32_t 32bit
        // https://www.cnblogs.com/loujiayu/p/3821108.html
        //Gi(x)=H1(x)+iH2(x)
        //H2(x)=(H1(x)>>17) | (H1(x)<<15)
        uint32_t h = BloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits 循环右移17位
        // save delete pos if exist and remove together
        std::vector<int> del_pos;
        for (size_t j = 0; j < k_; j++) {
            //计算并更新对应的Bytes++
            const uint32_t bucket_pos = h % bytes_;
            // bucket++
            // no this key and return false
            if (array[bucket_pos] == 0)return false;
            del_pos.push_back(bucket_pos);
        
            h += delta;
        };
        for(int pos:del_pos){
                array[pos]--;
        }
        return true;
    }

    virtual bool KeyMayMatch(const std::string &key) const {
        const size_t len = data_.size();
        if (len < 2) return false;

        const char *array = data_.data();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];

        uint32_t h = BloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
        for (size_t j = 0; j < k; j++) {
            const uint32_t bucket_pos = h % bytes_;
            // not exist return false
            if (array[bucket_pos] == 0)return false;
            h += delta;
        }
        return true;
    }
    virtual void DumpData() const {
        std::cout<<data_<<std::endl;
    }
};


const FilterPolicy *NewCountBloomFilterPolicy(int buckets_per_key, int key_num) {
    return new CountBloomFilterPolicy(buckets_per_key, key_num);
}