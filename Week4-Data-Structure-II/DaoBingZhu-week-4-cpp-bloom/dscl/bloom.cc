// Created by IcePig on 2020-07-27.
#include <iostream>
#include "filter_policy.h"
#include "util/hash.h"


static uint32_t BloomHash(const std::string &key) {
    // string.data() exclude '/0'
    // string.c_str() include '/0'
    return Hash(key.c_str(), key.size(), 0xbc9f1d34);
}

class BloomFilterPolicy : public FilterPolicy {
private:
    size_t bits_per_key_; // m/n
    size_t k_;            // hash function nums
    size_t bits_;         // total bits
    std::string data_;

public:
    //记录bits_per_key，计算最优的hash函数个数
    explicit BloomFilterPolicy(int bits_per_key,int key_num)
            : bits_per_key_(bits_per_key),data_(std::string()) {
        // We intentionally round down to reduce probing cost a little bit
        // bits_per_key = m / n  根据公式传入 bits_per_key
        // 相当于传入了希望的错误率，会自动算出需要使用的哈希函数个数k
        // m = -[(n * lnp)/(ln2)^2]     p:p(error)
        // k_ = ln(2) * bits_per_key
        k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
        // [1, 30]个hash函数
        if (k_ < 1) k_ = 1;
        if (k_ > 30) k_ = 30;
        // Compute bloom filter size (in both bits and bytes)
        // 计算需要的bit数
        bits_ = key_num * bits_per_key;
        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits_ < 64) bits_ = 64;

        size_t bytes= (bits_+7)/8;
        bits_ = bytes*8;
        data_.resize(bytes,0);
        data_.push_back(static_cast<char>(k_));
    }

    virtual const char *Name() const {
        return "leveldb.BuiltinBloomFilter.variant";
    }

    virtual void AddKey(const std::string *keys, int n) const {
        char *array = (char*)(data_.c_str());//更新array <-> data_[0 :bytes]
        // char *array = &(*data_)[0];//更新array <-> dst[init_size : init_size + bytes]
        for (int i = 0; i < n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            // uint32_t 32bit
            // https://www.cnblogs.com/loujiayu/p/3821108.html
            //Gi(x)=H1(x)+iH2(x)
            //H2(x)=(H1(x)>>17) | (H1(x)<<15)
            uint32_t h = BloomHash(keys[i]);
            const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits 循环右移17位
            for (size_t j = 0; j < k_; j++) {
                //计算并更新对应的bit为1
                const uint32_t bitpos = h % bits_;
                array[bitpos / 8] |= (1 << (bitpos % 8));
                h += delta;
            }
        }
    }
    virtual bool KeyMayMatch(const std::string &key) const {
        const size_t len = data_.size();
        if (len < 2) return false;

        const char *array = data_.data();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len - 1];

        uint32_t h = BloomHash(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
        for (size_t j = 0; j < k; j++) {
            const uint32_t bitpos = h % bits;
            if ((array[bitpos / 8] & (1 << (bitpos % 8))) == 0) return false;
            h += delta;
        }
        return true;
    }
    virtual void DumpData() const {
        std::cout<<data_<<std::endl;
    }
};


const FilterPolicy *NewBloomFilterPolicy(int bits_per_key,int key_num) {
    return new BloomFilterPolicy(bits_per_key,key_num);
}