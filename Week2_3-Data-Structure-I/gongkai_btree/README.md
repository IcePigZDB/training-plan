# 第二、三周学习内容

## SkipList

>在有序的链表中，并且在链表比较长的情况下，此时链表查找时间复杂度为O(n)。利用二分查找的思想对一般的链表加以设计，类似二叉搜索树，以空间换取时间。

>在Reids中有序集合zset采用的就是跳表结构，针对zset需要快速的插入和删除，自然想到链表，并且链表的中的数据是由key和value组成的。zset还支持有序和范围查找，有序我们需要保持链表有序，对于查找，在数据量大的情况下，skiplist建立的索引把时间复杂度降为了O（logn）


跳表具有如下性质：
+ 由很多层结构组成
+ 每一层都是一个有序的链表
+ 最底层的链表包含所有元素
+ 如果一个元素出现在第i（i>=2）层中，那它在i-1层及其以下的链表中也会出现
+ 每个节点包含两个指针，一个指向同一链表的下一个元素，一个指向下一层的元素

***

## B树

>在二叉平衡树中，当数据量比较大时，树的深度会非常大，如果利用二叉平衡树建立数据库的索引，由于磁盘读取数据是以数据块为单位，随着树的深度加大，IO次数也会非常多。为了解决这个问题，有了B树，即在每个节点中不止存放一个关键字，针对外部查找，将会大大降低IO次数

B树具有如下性质：
+ 元素集合分布在整颗树中
+ 任何一个元素出现且只出现在一个节点中
+ 搜索有可能在非叶子节点结束
+ 因为每个节点中的元素和子树都是有序的，其搜索性能等价于在元素集合内做一次m分查找
+ B树在插入删除新的数据记录会破坏B-Tree的性质，因为在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质

***

## B+树

>相比于B树，B+树叶子结点包含全部关键字以及指向相应记录的指针，而且叶结点中的关键字按大小顺序排列，相邻叶结点用指针连接，非叶节点仅存储其子树的最大或最小关键字，可以看成是索引。

>B+树更适合外部存储。由于内结点不存放真正的数据（只是存放其子树的最大或最小的关键字，作为索引），一个结点可以存储更多的关键字，每个结点能索引的范围更大更精确，也意味着B+树单次磁盘IO的信息量大于B树，I/O的次数相对减少。并且B+树增加的链指针，加强了区间访问性，可使用在区间查询的场景，而B树没有这种性质。

B+树性质
+ 叶子结点包含全部关键字以及指向相应记录的指针，而且叶结点中的关键字按大小顺序排列，相邻叶结点用指针连接
+ 非叶结点仅存储其子树的最大（或最小）关键字，可以看成是索引
  
***

## LSM tree
>LSM-tree 是专门为 key-value 存储系统设计的，key-value 类型的存储系统最主要的就两个个功能，put（k，v）：写入一个（k，v），get（k）：给定一个 k 查找 v。LSM-tree 最大的特点就是写入速度快，主要利用了磁盘的顺序写，pk掉了需要随机写入的 B-tree。

LSM-tree性质
+ 写入速度快，主要利用了磁盘的顺序写
+ 一次查询可能需要多次单点查询，查询速度会比较慢
+ 主要缺点是读写放大

***

## B树的C++实现及测试

B树节点的结构体具体设计

 ```
 typedef struct BTNode {
    int keynum;
    KeyType key[m + 1];  //不用key[0]
    struct BTNode *parent;
    struct BTNode *ptr[m + 1];
} BTNode, *BTree;   
 ```

 ### Btree的插入
1. 根据要插入的key,找到叶子结点并插入
2. 判断当前结点key的个数是否小于等于m-1，若满足则结束，若不满足，则进行第三步
3. 以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，如果不存在父结点，则新建一个父结点，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点。
4. 当前结点定位到父结点，继续执行第2步

### Btree的查询
1. 首先查找根结点，如果查询到该key则返回查找成功
2. 找到该结点第一个大于key的关键字key[i],进入ptr[i]所指向的子树进行查找，若子树为空，则返回查找失败，否则进入第1步

### Btree的遍历
1. 层次遍历利用队列，依次输出每一层结点的key
2. 中序遍历，采用递归的方法，将B树所有结点按从小到大的顺序输出

### Btree的删除
1. 如果只有一个根结点，则找到target直接将其删除
2. 如果target在非叶子结点中，找到target位于叶子结点上的后继关键字将其替换，问题转为删除某个叶子结点上的关键字
3. 直接删除该关键字，如果删除后该结点的关键字总数小于（m-1）/2，如果左右两边的兄弟结点有富余的结点（即满足最少的情况），进入4步骤，否则进入5步骤
4. 将兄弟结点最左边的关键字移到父结点最右边，将父结点最右关键字移到该结点中
5. 进行结点的合并，将父结点和兄弟结点的关键字全部移到该结点，删除兄弟结点，继续调整夫结点，进入步骤3

### 编译及测试

进入b-tree目录下运行命令

`g++ test.cpp btree.cpp -lgtest -lpthread`
`./a.out `

测试结果：

```
[==========] Running 1 test from 1 test suite.
[----------] Global test environment set-up.
[----------] 1 test from btreee
[ RUN      ] btreee.insert
73 142 205 215 227 266 281 408 426 463 529 538 547 574 649 675 841 891 996 1897 426
227   574
142   281   529   675,891
73   205,215   266   408   463   538,547   649   841   996,1897
[       OK ] btreee.insert (0 ms)
[----------] 1 test from btreee (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test suite ran. (1 ms total)
[  PASSED  ] 1 test.

```