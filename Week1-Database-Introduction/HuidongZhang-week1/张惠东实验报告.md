# 周报Week1

- [关系型数据库MySQL](#关系型数据库mysql)
  - [环境配置](#环境配置)
  - [基本架构](#基本架构)
  - [基本操作](#基本操作)
  - [删表操作](#删表操作)
  - [MySQL日志](#mysql日志)
  - [遇到的问题](#遇到的问题)
  - [TODO](#todo)
- [文档型数据库MongoDB](#文档型数据库mongodb)
  - [环境配置](#环境配置-1)
  - [基本架构](#基本架构-1)
  - [M001: MongoDB Basics(仅完成Chapter0,1以及Chapter2的部分内容)](#m001-mongodb-basics仅完成chapter01以及chapter2的部分内容)
  - [MongoDB Query  Language](#mongodb-query-language)
  - [遇到的问题](#遇到的问题-1)
  - [TODO](#todo-1)
- [KV型数据库Redis](#kv型数据库redis)
  - [环境配置](#环境配置-2)
  - [基本架构](#基本架构-2)
  - [基本语句](#基本语句)
  - [TODO](#todo-2)
- [图数据库Janusgraph](#图数据库janusgraph)
  - [环境配置](#环境配置-3)
  - [基本操作](#基本操作-1)
  - [基础架构](#基础架构)
  - [TODO](#todo-3)

***

实验环境：Ubuntu 20.04 LTS

***

## 关系型数据库MySQL

- [x] 了解MySQL环境配置
- [x] 了解MySQL基本架构
- [x] 了解MySQL基本语句
- [x] ~~了解MySQL日志管理~~   **简单看了一下，本学期的“数据库原理及其应用”课程涉及到日志管理相关内容，准备复习的时候一块看**

### 环境配置

```shell
# 下载安装MySQL
sudo apt update
sudo apt install mysql-server

# 修改密码
sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf # 添加skip-grant-tables
service mysql restart
mysql -u root -p
mysql> use mysql
mysql> flush privileges;
mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '******';
mysql> flush privileges;
mysql> exit;
sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf # 删除skip-grant-tables

# 卸载MySQL
sudo apt remove mysql-common
sudo apt autoremove --purge mysql-server-8.0
dpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P
dpkg --list|grep mysql
sudo apt autoremove --purge mysql-apt-config　# 如有残余项，按这种方式删除
```

### 基本架构

MySQL的基本架构图如图sql_basic_structure所示。对MySQL架构的描述可以查看[MySQL 基本架构概览](https://www.jianshu.com/p/9bb38b80175f)。

<center>    
<div align=center>
<img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="./fig/sql_basic_structure.png">    
<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">sql_basic_structure</div> 
</div>
</center>



### 基本操作

```mysql
# 创建数据库Week1
drop database if exists Week1;
create database Week1;
use Week1

# 创建数据表student, student_info 
drop table if exists student;
drop table if exists student_info;
create table student(
  `id`  int(11),
  `name`  varchar(20)
);
create table student_info(
  `id`  int(11),
  `schoolNo`  varchar(20),
  `age` int(11)
);

# 插入测试数据
insert into student
(id, name)
values
(0, '张惠东');
insert into student_info
(id, schoolNo, age)
values
(0, '2017100101021', 21);

# 查询'张惠东'的schoolNo和age
select schoolNo, age 
from student, student_info 
where name='张惠东';

# 删除数据表
drop table student;
# delete from table student;
# truncate table student;
drop table student_info;
# delete from table student_info;
# truncate table student_info;
```

### 删表操作

关于drop, delete, truncate的区别，可以查看[MySQL删除表操作](https://blog.csdn.net/z_ryan/article/details/81913481)

在删除大表的时候，可能会出现MySQL服务挂起，可以查看[MySQL删除大表时潜在的问题](https://www.cnblogs.com/wy123/p/11763293.html)

### MySQL日志

[MySQL日志模块](https://blog.csdn.net/OrangeRawNorthland/article/details/85321170)

[MySQL事务日志](https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html)

### 遇到的问题

1. 在修改mysql密码的时候，最初使用的是`update user set authentication_string=PASSWORD('150521') where user='root';`，然后报**语法错误**。其中`PASSWORD()`函数将输入的密码转化为哈希编码，据此我做了相关实验。
   - 首先，MySQL会在数据库mysql中的user表中存储用户密码（如图desc_user），修改密码的原理就是修改mysql数据库中存储的用户root的登陆密码，对应字段为authentication_string。查询上述字段的信息，得到查询的结果如图auth_str所示，可以看出密码是被哈希加密过的。
   - 然后，在MySQL8.0版本，`PASSWORD()`被废弃，我查询相关说明，使用新本能够接受的修改密码的语句，最终成功修改密码，并且修改过的密码也是哈希加密过的。

<center>    
<div align=center>
<img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="./fig/sql_desc_user.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">sql_desc_user</div> 
</div>
</center>

<center>    
<div align=center>
<img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="./fig/sql_auth_str.png">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">sql_auth_str</div> 
</div>
</center>

### TODO

- 深入学习MySQL的日志管理机制。



## 文档型数据库MongoDB

- [x] 了解MongoDB环境配置
- [x] 了解MongoDB基本架构
- [x] 学习M001课程的Chapter0,1以及Chapter2的部分内容
- [x] ~~了解MongoDB基本操作~~   **没有细看**

### 环境配置

```shell
# 下载安装MongoDB
sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4
echo "deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu $(lsb_release -cs)/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list
sudo apt update
sudo apt install -y mongodb-org

# 启动MongoDB服务
service mongod start
# sudo service mongod status
# sudo service mongod stop
# sudo service mongod restart
mongo

# 卸载MongoDB
sudo service mongod stop
sudo apt-get purge mongodb-org*
sudo rm -r /var/log/mongodb
sudo rm -r /var/lib/mongodb
```

### 基本架构

MongoDB数据库的架构学习，可以参考[MongoDB架构学习笔记](https://blog.csdn.net/gongxsh00/article/details/80132029)。

### M001: MongoDB Basics(仅完成Chapter0,1以及Chapter2的部分内容)

Atlas：支持MongoDB数据库在云端部署，使用数据库服务（Amazon）需要访问Amazon AWS的27017端口。

```shell
# 测试能否访问Amazon AWS的27017端口
telnet cluster0-shard-00-00-jxeqq.mongodb.net 27017

# 登陆M001课程的atlas集群
mongo "mongodb+srv://cluster0-jxeqq.mongodb.net/test" --username m001-student -password m001-mongodb-basics
```

Compass：提供操作MongoDB的可视化界面。

```shell
# Connect to your deployment

# Using the connection string
mongodb+srv://m001-student:m001-mongodb-basics@cluster0-jxeqq.mongodb.net/test

# Filling out deployment information in individual fields
Hostname: cluster0-shard-00-00-jxeqq.mongodb.net
Port: 27017
Authentication: Username / Password
Username: m001-student
Password: m001-mongodb-basics
Authentication Database: admin
```

### MongoDB Query  Language

MongoDB的查询语言，操作符之类的，可以参考[官方文档](https://docs.mongodb.com/manual/crud/)。

### 遇到的问题

创建自己的Mongodb Atlas集群的时候，没有看见Primary节点。在使用shell连接集群的时候，报错`[could not find host matching read preference { mode: \“primary\” ...} `，我猜测是没有Primary节点的问题，~~暂时没有找到解决办法~~，**更新**：Primary节点莫名其妙地出现了，现在能够连接服务集群了，有Primary节点的图如图mongodb_atlas_primary所示。

<center>    
<div align=center>
<img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="./fig/mongodb_atlas_primary.png">   
<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">mongodb_atlas_primary</div> 
</div>
</center>

### TODO

- 在Atlas服务器集群上进行增删改查操作，有时间的话可以完成MongoDB University的后续课程。



## KV型数据库Redis

- [x] 了解Redis环境配置
- [x] 了解Redis基本架构
- [x] 了解Redis基本语句

### 环境配置

```shell
# 下载安装Redis
sudo apt install redis-server

# 启动redis服务器
service redis-server start
sudo vim /etc/redis/redis.conf # 修改Redis配置文件
service redis-server restart
redis-cli -a ******
# service redis-server stop
```

### 基本架构

Redis的基本架构可以查看[Redis架构](https://www.cnblogs.com/wxzhe/p/10751449.html)，博主的其他文章有系统介绍Redis和MongoDB。

Redis的数据结构可以查看[官方文档](https://redis.io/topics/data-types-intro)。

### 基本语句

```shell
# Redis的Key值是string(string是Redis的基本数据结构)，Value值可以是任何Redis接受的数据结构
# set方法可以有一些postfix，如nx(Not Exists)，xx(Exists)之类的
> set mykey somevalue
OK
> get mykey
"somevalue"
> set mykey newval nx
(nil)
> set mykey newval xx
OK

# incr，incrby，decr，decrby增减操作，操作具有原子性，不同用户同时操作，读取到的数据不一样
> set counter 100
OK
> incr counter
(integer) 101
> incr counter
(integer) 102
> incrby counter 50
(integer) 152

# exists，type，del
> exists counter
(integer) 1
> type counter
string
> del counter
(integer) 1
> exists counter 
(integer) 0
> type counter
none

# expire限制key的生存时间，或者在set方法中使用ex，px之类的postfix操作
# ttl(pttl)查询key的剩余生存时间
> set key some-value
OK
> expire key 5
(integer) 1
> get key (immediately)
"some-value"
> get key (after some time)
(nil)
> set key 100 ex 10
OK
> ttl key
(integer) 9

# Redis中的List是通过链表实现，可以快速在链表首部或尾部插入元素
# r(l)push尾(首)部插入，r(l)pop尾(首)部删除，ltrim保留尾部若干元素，lrange逆序遍历
> rpush mylist A
(integer) 1
> rpush mylist B
(integer) 2
> lpush mylist first
(integer) 3
> lrange mylist 0 -1
1) "first"
2) "A"
3) "B"
> rpop mylist 
"B"
> lrange mylist 0 -1
1) "first"
2) "A"

# Capped Lists
> rpush mylist 1 2 3 4 5
(integer) 5
> ltrim mylist 0 2
OK
> lrange mylist 0 -1
1) "1"
2) "2"
3) "3"

# brpop, blpop是为了减少无用的命令，缩短线程的等待时间（list为空时，client请求的返回结果是NULL，brpop,blpop延时一段时间再决定是否返回NULL），并且返回list的名称（适用于针对multi-lists的请求）
> brpop mylist 5
1) "mylist"
2) "A"
> brpop mylist 5
1) "mylist"
2) "first"
> brpop mylist 5
(nil)
(5.05s)

# hset设置hash field对应的属性名和属性值
# hincrby对标incrby
> hmset user:1000 username antirez birthyear 1977 verified 1
OK
> hget user:1000 username
"antirez"
> hget user:1000 birthyear
"1977"
> hgetall user:1000
1) "username"
2) "antirez"
3) "birthyear"
4) "1977"
5) "verified"
6) "1"
> hmget user:1000 username birthyear no-such-field
1) "antirez"
2) "1977"
3) (nil)
> hincrby user:1000 birthyear 10
(integer) 1987
> hincrby user:1000 birthyear 10
(integer) 1997

# sets是strings的无序集合，sadd向该集合中插入元素，smembers查看集合元素
> sadd myset 1 2 3
(integer) 3
> smembers myset
1. 3
2. 1
3. 2
> sismember myset 3
(integer) 1
> sismember myset 30
(integer) 0

# 集合特有的操作，unionstore：返回无相同元素的集合，scard：返回集合的势
>  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK
(integer) 13
> sunionstore game:1:deck deck
(integer) 13
> scard deck
(integer) 13

# sorted sets 使用一个附加的score参数来维护key的排列顺序
# zadd对标sadd，zrange对标lrange，revrange逆序遍历，postfix withscores可以展示score，zrangebyscore可以限定范围
> zadd hackers 1940 "Alan Kay"
(integer) 1
> zadd hackers 1957 "Sophie Wilson"
(integer) 1
> zadd hackers 1953 "Richard Stallman"
(integer) 1
> zrange hackers 0 -1
1) "Alan Kay"
2) "Richard Stallman"
3) "Sophie Wilson"
> zrevrange hacker 0 -1
1) "Sophie Wilson"
2) "Richard Stallman"
3) "Alan Kay"
> zrange hackers 0 -1 withscores
1) "Alan Kay"
2) "1940"
3) "Richard Stallman"
4) "1953"
5) "Sophie Wilson"
6) "1957"
> zrangebyscore hackers -inf 1950
1) "Alan Kay"
```

### TODO

- 学习使用Redis的哨兵机制（或其他更先进的分布式机制），部署服务器集群。



## 图数据库Janusgraph

- [x] 了解Docker环境配置

- [x] 了解Docker下Janusgraph环境配置

- [x] 了解JanusGraph的基本操作

### 环境配置

```shell
# 下载安装Docker
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository \
   "deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \
  $(lsb_release -cs) \
  stable"
sudo apt install docker-ce
sudo docker run hello-world

# 卸载Docker
sudo apt remove docker docker-engine

# 下载和安装JanusGraph
# 需要安装外部数据库Cassandra和索引引擎Elasticsearch
docker run --name cassandra-3.11.3 -p 7000:7000 -p 7001:7001 -p 7199:7199 -p 9042:9042 -p 9160:9160 -d cassandra:3.11.3
docker run --name es-5.5.2 -p 9200:9200 -p 9300:9300 -d elasticsearch:5.5.2
wget https://github.com/JanusGraph/janusgraph/releases/download/v0.3.0/janusgraph-0.3.0-hadoop2.zip
cd janusgraph-0.3.0-hadoop2解压后的文件夹
vim conf/gremlin-server/gremlin-server.yaml # 修改配置文件
vim conf/gremlin-server/janusgraph-cql-es-server.properties # 修改配置文件
docker restart es-5.5.2
.bin/gremlin-server.sh ./conf/gremlin-server/gremlin-server.yaml
.bin/gremlin.sh
```

### 基本操作

Janusgraph支持的查询语言是Gremlin，在学习Janusgraph的基本操作时，过了一遍[官方文档](https://docs.janusgraph.org/getting-started/basic-usage/)的基础教程，使用的案例是The Graph of the Gods（如图janus_graph_model所示）。

<center>    
<div align=center>
<img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);"     src="./fig/janus_graph_model.png">    
<br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">janus_graph_model</div> 
</div>
</center>



```shell
# 获得The Graph of the Gods
gremlin> graph = JanusGraphFactory.open('conf/janusgraph-berkeleyje-es.properties')
==>standardjanusgraph[berkeleyje:../db/berkeley]
gremlin> GraphOfTheGodsFactory.load(graph)
==>null
gremlin> g = graph.traversal()
==>graphtraversalsource[standardjanusgraph[berkeleyje:../db/berkeley], standard]

# .V()获得节点，.V().has(key, value)根据vertex索引获得节点，.valueMap()获得节点的Map，.in()或.out()根据边进行索引，.values()获得某个属性
gremlin> saturn = g.V().has('name', 'saturn').next()
==>v[4320]
gremlin> g.V(saturn).valueMap()
==>[name:[saturn], age:[10000]]
gremlin> g.V(saturn).in('father').in('father').values('name')
==>hercules
gremlin> hercules = g.V(saturn).repeat(__.in('father')).times(2).next()
==>v[4312]
gremlin> g.V(hercules).out('mother').values('name')
==>alcmene
gremlin> g.V(hercules).outE('battled').has('time', gt(1)).inV().values('name')
==>cerberus
==>hydra

# .E().has(key, value)根据edge索引获得边
gremlin> g.E().has('place', geoWithin(Geoshape.circle(37.97, 23.72, 50)))
==>e[2sb-3bs-9hx-6i8][4312-battled->8432]
==>e[36j-3bs-9hx-9o0][4312-battled->12528]

# pluto节点
gremlin> pluto = g.V().has('name', 'pluto').next()
==>v[8440]

# 和pluto同居
gremlin> g.V(pluto).out('lives').in('lives').where(is(neq(pluto))).values('name')
==>cerberus

# pluto的兄弟的住所
g.V(pluto).out('brother').as('god').out('lives').as('place').select('god', 'place').by('name')
==>[god:jupiter, place:sky]
==>[god:neptune, place:sea]

# pluto在住所居住的原因
gremlin> g.V(pluto).outE('lives').values('reason')
==>no fear of death

# 在住所的原因是喜欢住所
gremlin> g.E().has('reason', textContains('loves')).as('source').values('reason').as('reason').select('source').outV().values('name').as('god').select('source').inV().values('name').as('thing').select('god', 'reason', 'thing')
==>[god:neptune, reason:loves waves, thing:sea]
==>[god:jupiter, reason:loves fresh breezes, thing:sky]

# 在[37.97, 23.72]半径20范围内发生过什么斗殴事件？具体地点？
gremlin> g.E().has('place', geoWithin(Geoshape.circle(37.97, 23.72, 20))).as('source').inV().as('monster').select('source').outV().as('god').select('god', 'source', 'monster').by('name').by('place')
==>[god:hercules,source:POINT (23.700001 38.099998),monster:nemean]
```

### 基础架构

基础架构的学习可以查看这篇文章，[JanusGraph基础架构](https://blog.csdn.net/leehsiao/article/details/90476007)。

### TODO

- 了解JanusGraph（或其他图数据库）的基础架构